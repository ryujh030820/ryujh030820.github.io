---
published: true
title: "[프로그래머스] [Level 3] 풍선 터트리기 (C++)"
date: 2024-09-27 22:35:00 +0900
categories: [Development, PS]
tags: [ps, 프로그래머스, c++]
---

## 문제 설명

일렬로 나열된 n개의 풍선이 있습니다. 모든 풍선에는 서로 다른 숫자가 써져 있습니다. 당신은 다음 과정을 반복하면서 풍선들을 단 1개만 남을 때까지 계속 터트리려고 합니다.

1. 임의의 **인접한** 두 풍선을 고른 뒤, 두 풍선 중 하나를 터트립니다.
2. 터진 풍선으로 인해 풍선들 사이에 빈 공간이 생겼다면, 빈 공간이 없도록 풍선들을 중앙으로 밀착시킵니다.

여기서 조건이 있습니다. 인접한 두 풍선 중에서 **번호가 더 작은 풍선**을 터트리는 행위는 최대 1번만 할 수 있습니다. 즉, 어떤 시점에서 인접한 두 풍선 중 번호가 더 작은 풍선을 터트렸다면, 그 이후에는 인접한 두 풍선을 고른 뒤 번호가 더 큰 풍선만을 터트릴 수 있습니다.

당신은 어떤 풍선이 최후까지 남을 수 있는지 알아보고 싶습니다. 위에 서술된 조건대로 풍선을 터트리다 보면, 어떤 풍선은 최후까지 남을 수도 있지만, 어떤 풍선은 무슨 수를 쓰더라도 마지막까지 남기는 것이 **불가능**할 수도 있습니다.

일렬로 나열된 풍선들의 번호가 담긴 배열 a가 주어집니다. 위에 서술된 규칙대로 풍선들을 1개만 남을 때까지 터트렸을 때 최후까지 남기는 것이 가능한 풍선들의 개수를 return 하도록 solution 함수를 완성해주세요.

## 제한 사항

- a의 길이는 1 이상 1,000,000 이하입니다.
  - `a[i]`는 i+1 번째 풍선에 써진 숫자를 의미합니다.
  - a의 모든 수는 -1,000,000,000 이상 1,000,000,000 이하인 정수입니다.
  - a의 모든 수는 서로 다릅니다.

## 입출력 예

| a                                       | result |
| --------------------------------------- | ------ |
| `[9,-1,-5]`                             | 3      |
| `[-16,27,65,-2,58,-92,-71,-68,-61,-33]` | 6      |

## 풀이

사실 처음에는 감이 잘 안 잡혔던 문제다. 임의의 **인접한** 두 풍선을 고른 뒤, 두 풍선 중 하나를 터뜨린다는게 핵심이다. 즉, 어떤 풍선을 마지막까지 남기고 싶던지 결국 해당 풍선의 왼쪽에 있는 풍선들 중 하나와 해당 풍선의 오른쪽에 있는 풍선들 중 하나와 비교해야 한다.

왼쪽에 있는 풍선들 중 번호가 제일 작은 풍선과 오른쪽에 있는 풍선들 중 번호가 제일 작은 풍선을 구한다.

이 풍선들은 남기고 싶은 풍선과 비교할 후보군이 되며, **번호가 더 작은 풍선을 터트리는 행위는 한 번만 가능**하므로 인접한 두 풍선 전부 다 번호가 남기고 싶은 풍선보다 작다면 마지막까지 남기는게 불가능해진다.

따라서, **제일 왼쪽에 있는 풍선과 제일 오른쪽에 있는 풍선은 무조건 마지막까지 남기는게 가능**하다.

이 때, 시간 복잡도가 $O(n^2)$이 되면 1000000\*1000000 = 10^12로 당연히 시간 초과가 나므로 왼쪽부터 시작하는 최솟값 배열과 오른쪽부터 시작하는 최솟값 배열을 만들어 $O(n)$으로 해결이 가능하도록 했다.

```cpp
#include <string>
#include <vector>

using namespace std;

int INF = 2e9;
int leftMinArray[1000000];
int rightMinArray[1000000];
int leftMin = INF;
int rightMin = INF;

int solution(vector<int> a) {
    int answer = 0;

    // 해당 풍선보다 더 작은 풍선이 최대 1개까지만 가능
    // 양 옆으로 나누어 무조건 더 큰 애들만 터뜨려서 비교 대상 정함
    for(int i = 0; i < a.size(); i++) {
        if(a[i] < leftMin) {
            leftMin = a[i];
        }

        leftMinArray[i] = leftMin;
    }

    for(int i = a.size() - 1; i >= 0; i--) {
        if(a[i] < rightMin) {
            rightMin = a[i];
        }

        rightMinArray[i] = rightMin;
    }

    for(int i = 0; i < a.size(); i++) {
        if(i == 0 || i == a.size() - 1) {
            answer++;
        } else {
            if(a[i] < leftMinArray[i - 1] || a[i] < rightMinArray[i + 1]) {
                answer++;
            }
        }
    }

    return answer;
}
```
